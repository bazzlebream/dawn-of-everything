import{_ as e,c as i,o as t,a}from"./app.b7c4ed3a.js";const f='{"title":"Clean Architecture with ASP.NET Core 2.1 | Jason Taylor","description":"","frontmatter":{},"headers":[{"level":2,"title":"domain","slug":"domain"},{"level":2,"title":"application layer","slug":"application-layer"},{"level":3,"title":"persistence","slug":"persistence"},{"level":3,"title":"infrastructure","slug":"infrastructure"},{"level":3,"title":"Presentation","slug":"presentation"}],"relativePath":"clean_architecture_with_asp_net_jason_taylor.md","lastUpdated":1640822311959}',l={},n=a('<h1 id="clean-architecture-with-asp-net-core-2-1-jason-taylor" tabindex="-1">Clean Architecture with <a href="http://ASP.NET" target="_blank" rel="noopener noreferrer">ASP.NET</a> Core 2.1 | Jason Taylor <a class="header-anchor" href="#clean-architecture-with-asp-net-core-2-1-jason-taylor" aria-hidden="true">#</a></h1><p><a href="https://www.youtube.com/watch?v=_lwCVE_XgqI&amp;t=1s" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=_lwCVE_XgqI&amp;t=1s</a><a href="https://jasontaylor.dev/" target="_blank" rel="noopener noreferrer">https://jasontaylor.dev/</a></p><ul><li><p><strong>convention over configuration</strong>[^1]</p><ul><li>the environment (which could mean the language, or libraries) assumes many situations by default, so you only specify (configure) what is <strong>not</strong> the default</li><li></li></ul></li><li><p>core:</p><ul><li>all logic</li></ul></li><li><p>domain</p><ul><li>enterprise-wide types and logic</li></ul></li><li><p>application</p><ul><li>not shared with other apps</li></ul></li><li><p>infrastructure (infrastructure and persistence are both &quot;infrastructure&quot;)</p><ul><li>persistence <ul><li>(here is alternate approach to using data annotations in csharp)</li></ul></li></ul></li><li><p>presentation</p></li></ul><p>infrastructure and presentation both</p><ul><li>depend on Application only</li><li>(thus) don&#39;t depend on each other</li><li>either can be replaced with minimal effort</li></ul><h2 id="domain" tabindex="-1">domain <a class="header-anchor" href="#domain" aria-hidden="true">#</a></h2><ul><li>entities <ul><li>set collections as private so they can&#39;t be initialized by someone else</li><li>and initialize in constructor or with property injection</li></ul></li><li>value object <ul><li>as opposed to primitive types</li><li>custom domain exceptions</li></ul></li><li>enumerations</li><li>logic</li><li>exceptions <ul><li>(custom domain exceptions)</li></ul></li></ul><h2 id="application-layer" tabindex="-1">application layer <a class="header-anchor" href="#application-layer" aria-hidden="true">#</a></h2><ul><li><p>outermost layer of core</p></li><li><p>most business logic here</p></li><li><p>work really hard to make sure core will be there in 20 years lol</p></li><li><p>everything outside of core is exchangeable</p></li><li><p>interfaces</p></li><li><p>models</p></li><li><p>logic</p></li><li><p>commands/queries</p></li><li><p>validators</p><ul><li>fluent validation better than data annotations <img src="https://i.imgur.com/T6rnZ3s.png" alt="fluent validation"></li></ul></li><li><p>exceptions</p></li></ul><p>CQRS</p><ul><li>command query responsibility segreation</li><li>separates reads from writes</li><li>maximize simplicity</li></ul><p>MediatR + CQRS</p><ul><li>pub/sub?</li><li>violates explicit dependencies principle: all dependencies should be explicit</li><li>when use mediatr, there&#39;s on dependency: mediatr</li><li>everything is a request (define queries and commands as requests)</li><li>application layer is series of req/res objects</li><li>can attach additional beha ior before/after requests (middleware)</li></ul><p>e.g. mediator behavior to validate request using validator</p><p>validation has to happen in core; that&#39;s a business rule; if we switch out webui for console UI, want validation to still be there \u2022 if in <a href="http://asp.net" target="_blank" rel="noopener noreferrer">asp.net</a>, not as useful</p><p>query</p><ul><li>get customer detail query - just dto (info to send to application layer) <ul><li>and query handler (grt customer detail handler)</li><li>supports dependency injection (e \u2022g \u2022 context)</li></ul></li></ul><p>(if you move entities out of core, then create depencies betwen external and internal, and the customerdto desn&#39;t contain all details we need (for client) - not a good idea to send entities out , since they are low level; better to send dto&#39;s out, cause we can customize them (such as adding whether or not the user can edit something)</p><h3 id="persistence" tabindex="-1">persistence <a class="header-anchor" href="#persistence" aria-hidden="true">#</a></h3><ul><li><p>dbcontext</p></li><li><p>migrations</p></li><li><p>configurations</p></li><li><p>seeding</p></li><li><p>abstractions</p></li><li><p>should be implement Unit of Work and Repository Patterns?</p><ul><li>(with entity framework core 2.1)</li><li>not always best choice</li><li>DbContext insulates code from database changes</li><li>DBContext acts as a &quot;unit of work&quot; ?</li><li>DBSet acts as a repository</li></ul></li><li><p>EF Core (entity framework core) has features for unit testing without repositories</p></li></ul><p>with DbContext, anyone can do what they want Repositories allow you to control access to the Entities (EF)</p><ul><li>like, wouldn&#39;t be able to edit an order detail unless do a whole &quot;update the whole order&quot; thing, if you designed it that way</li></ul><p>better to less good convention configuration (move fluentApi Configuration something api into separate file so you &quot;don&#39;t mess up the entity&quot;) data annotation</p><p>use an extension to automatically apply all entity type configurations</p><h3 id="infrastructure" tabindex="-1">infrastructure <a class="header-anchor" href="#infrastructure" aria-hidden="true">#</a></h3><ul><li>implementation only (abstractions and interfaces contained within CORE) <ul><li>api clients</li><li>file system</li><li>email</li><li>clock</li><li>anything external</li></ul></li><li>no layers depend on infrastructure (eg presentation)</li><li>contains classe for accessing external resources (see above)</li><li>implements abstractions/interfaces defined within Application layer</li></ul><p>&quot;core dealing with external concerns via dependency inversion&quot; ?inversion <img src="https://i.imgur.com/BeSHatW.png" alt=""></p><h3 id="presentation" tabindex="-1">Presentation <a class="header-anchor" href="#presentation" aria-hidden="true">#</a></h3><ul><li>whatever you want</li></ul><p>typically controller: <img src="https://i.imgur.com/5DagfVY.png" alt=""></p><p>OpenApi</p><p><img src="https://i.imgur.com/SUycVG9.png" alt=""><img src="https://i.imgur.com/ghNGkND.png" alt=""><img src="https://i.imgur.com/RtmPi99.png" alt=""> [^1]: <a href="https://facilethings.com/blog/en/convention-over-configuration" target="_blank" rel="noopener noreferrer">https://facilethings.com/blog/en/convention-over-configuration</a></p>',32),o=[n];function r(s,p,c,u,d,h){return t(),i("div",null,o)}var g=e(l,[["render",r]]);export{f as __pageData,g as default};
